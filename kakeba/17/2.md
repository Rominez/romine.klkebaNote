Paxos 是一种基于消息传递的、具有高容错性的一致性算法  
在分布式系统中如何就某个决议达成一致  

拜占庭将军问题：  
如果某个节点的意见在发送过程中遭到篡改，负责决议的节点接收到的信息不真实，那么决议结果也是有问题的  
在不可靠信道上试图通过消息传递的方式达到一致性是不可能的  

Paxos 算法的前提是信道安全可靠  

分布式系统中各个节点间采用的通讯模型  
- 共享内存：节点将意见统一发送至某一个节点，然后由这个节点下决议  
- 消息传递：节点之间相互通信，n 个节点中每一个节点都要进行 n-1 次通信，没有一个统一的节点，节点越多需要的通信就越多  

Paxos 算法是基于消息传递通讯模型的  

Paxos 根据不同行为区分出来的角色  
- Proposer 提案者：提出提案的节点  
- Acceptor 表决者：接受提案并给出意见的节点  
- Learner 同步者：问题已有结论，同步这个结论结果的节点  

Paxos 算法的一致性  
- 问题提出时，首先获取一个全局唯一的、递增的提案编号 N。后提出的提议对应的 N 一定比先提出的大  
- 表决者 accept 一个提案后，会将 N 记录在本地  
设本地 accept 过的最大的 N 为 maxN，表决者**仅会 accept 大于 maxN 的提案**  
- 众多提案最终只有一个提案被**选定**  
- 其他节点会主动同步被选定的提案  
- 没有问题提出则不会有提案被选定  

Paxos 算法流程  
- 准备阶段 prepare  
    - 提案者准备提交提议 N，先向某一个表决者发出 prepare(N) 请求，**试探**其是否支持该编号的提议  
    表决者得到 N，与 maxN 进行比较  
        - `N < maxN` 则该提议**过时**，不回应或回应 error  
        - `N > maxN` 将 N 记录下来，然后将 maxN 反馈给提案者  
        ```
        proposal(
            myid, // 该表决者的编号  
            maxN, // 表决者的 maxN，没有时为 null
            value // maxN 对应的提案内容，没有时为 null
        )
        ```
        - `N == maxN` 的情况不存在，N 是由原来的数值采用同步锁的方式增一    
    - 提案者向下一个表决者重复上一步，直到获取到过半的 maxN 反馈或者全部试探完毕，若未能收到过半的 maxN 反馈，该提案被集群视为过时，重新获取 N 或者放弃提案  
- accept 阶段  
    - 提案者向一个表决者发起 proposal(N)  
    - 表决者在 `N >= maxN || N >= prepareN`  时响应 ACK 表示 accept  
    - 提案者向下一个节点发起 proposal(N)，当收到过半节点的 ACK 响应时，向响应节点发送 commit 指令，向其余节点发送 proposal + commit  
    - 接收到 commit 指令的节点成为同步者  

Paxos 算法的活锁问题  
节点在 accept 时因 prepareN 被其他节点更新而失败，于是更新 N 再次进行重试，又影响了其他节点的 accept 阶段，最终互相干扰导致都不能 commit  
活锁问题的解决方案是，集群中只允许一个节点（zookeeper 中的 leader 节点）提交提案，该节点对 N 具有唯一操作权  

Paxos 算法中引入节点状态  
如果将接受 proposal 后和 commit 前的节点设置为 Learning 状态，该状态下的节点不接受 prepare 请求  
多个 leader 发起提案后会因这个状态将集群中的节点分成不同的 Learning 状态  
此时收到过半节点支持的 leader 通过提案，其他 leader 通知对应表决者取消 learning 状态  

[back](../17.md)  