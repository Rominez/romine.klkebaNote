减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法  
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸；一个线程里的对象被另一个线程引用，称为线程逃逸；全局变量逃逸；方法返回值逃逸；实例引用逃逸  
作用域不在方法内的对象，可能被其他方法改变  
对于没有逃逸的对象，我们可以有很多优化策略  
- 同步策略  
如果一个对象只能被一个线程访问，那么这个对象的操作可以不考虑同步  
- 将堆分配转化为栈分配  
如果一个对象在子程序中被分配，并且该对象不会逃逸，那么对象可能分配到方法栈里而不是堆空间  
- 分离对象或标量替换  

开启逃逸分析 `-XX:+DoEscapeAnalysis` 1.7 默认开启  

#### 对象的栈上内存分配  

JIT编译器可以在编译期间根据逃逸分析的结果，决定是否可以将对象的内存分配从堆转化为栈。没有发生方法逃逸的对象可以放到栈空间  
一个方法的栈空间会随着方法的结束销毁，将对象分配到栈空间可以减小GC消耗  

#### 标量替换  

标量指的是基本数据类型的数据，指无法再分解成更小的数据的数据  
标量替换就是将一个对象成员拆分成标量进行存储  
一个对象在内存结构上有三个部分：存储对象信息的对象头，存储成员的实例数据，以及对齐填充部分。  
如果一个对象只需要实例部分，那么就可以进行标量替换，把成员拆分出来像方法里的局部变量一样放到栈空间  

#### 同步锁消除  
当加锁的对象不会发生线程逃逸，完全没有必要加锁（如一些StringBuffer），那么jit编译时就可以将同步锁去掉以减少加锁解锁带来的开销  
关闭同步锁消除功能 `-XX:-EliminateLocks`  


[back](../5.md)  