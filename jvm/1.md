# JIT  

## 执行引擎 
- 解释器：字节码的逐行执行，一行一行解释成机器码  
更高的执行效率，节约内存  
- JIT 编译器在运行时进行编译（动态编译），将某一部分代码进行编译成机器码。JIT 以方法为单位进行编译  

调用频率高的代码进行动态编译  

## 热点代码  

- 被调用N次 client 1500 server 10000 
- 被循环N次  

---

- 方法调用计数器：在方法对象中存储调用次数  
- 回边计数器： 每次循环记录一次次数  

--- 

## 优化  

### 公共子表达式的消除  

在JIT编译时进行对代码的优化，减少重复的表达式  
代数化简  

### 方法内联  

将一个方法放到调用这个方法的栈里，减少压栈和入栈的开销  
小方法被频繁的执行  

### 逃逸分析  

减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法  
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸；一个线程里的对象被另一个线程引用，称为线程逃逸；全局变量逃逸；方法返回值逃逸；实例引用逃逸  
作用域不在方法内的对象，可能被其他方法改变  
对于没有逃逸的对象，我们可以有很多优化策略  
- 同步策略  
如果一个对象只能被一个线程访问，那么这个对象的操作可以不考虑同步  
- 将堆分配转化为栈分配  
如果一个对象在子程序中被分配，并且该对象不会逃逸，那么对象可能分配到方法栈里而不是堆空间  
- 分离对象或标量替换  

开启逃逸分析 `-XX:+DoEscapeAnalysis` 1.7 默认开启  

#### 对象的栈上内存分配  

JIT编译器可以在编译期间根据逃逸分析的结果，决定是否可以将对象的内存分配从堆转化为栈。没有发生方法逃逸的对象可以放到栈空间  
一个方法的栈空间会随着方法的结束销毁，将对象分配到栈空间可以减小GC消耗  

#### 标量替换  

标量指的是基本数据类型的数据，指无法再分解成更小的数据的数据  
标量替换就是将一个对象成员拆分成标量进行存储  
一个对象在内存结构上有三个部分：存储对象信息的对象头，存储成员的实例数据，以及对齐填充部分。  
如果一个对象只需要实例部分，那么就可以进行标量替换，把成员拆分出来像方法里的局部变量一样放到栈空间  

#### 锁消除  
当加锁的对象不会发生线程逃逸，完全没有必要加锁，那么jit编译时就可以将同步锁去掉以减少加锁解锁带来的开销  
关闭同步锁消除功能 `-XX:-EliminateLocks`  

### Class 文件  

16进制字节码文件  
结构  
- 4 byte 魔数，固定值CAFEBABE，作用类似文件扩展名  
- 2 byte 副版本号 minor version
- 2 byte 主版本号 major version
- 2 byte 常量池计数器，值=常量个数+1  
- 常量池数据区，从#1开始，#0表达不引用任何一个常量池项  
- 2 byte 访问标志
- 2 byte 类索引
- 2 byte 父类索引
- 2 byte 接口计数器
- 接口信息数据区
- 2 byte 字段计数器
- 字段信息数据区
- 2 byte 方法计数器
- 方法信息数据区

| JDK版本 | 16进制 | 10进制 |
| :-: | :-: | :-: |
| JDK8 | 00 00 00 34 | 52 |
| JDK7 | 00 00 00 33 | 51 |
| JDK6 | 00 00 00 32 | 50 |
| JDK5 | 00 00 00 31 | 49 |
| JDK1.4 | 00 00 00 30 | 48 |
| JDK1.3 | 00 00 00 2F | 47 |
| JDK1.2 | 00 00 00 2E | 46 |
| JDK1.1 | 00 00 00 2D | 45 |

查看 class 文件命令 `javap -v #文件名`  

访问标志  
| 标记名 | 值 | 含义 |
| :- | :-: | :- |
| ACC_PUBLIC | 0X0001 | 可以被包外的类访问 |
| ACC_FINAL | 0X0010 | 不允许有子类 | 
| ACC_SUPER | 0x0020 | 当用到 invokespecial 指令时需要特殊处理的父类方法 |
| ACC_INITERFACE | 0x0200 | 接口 |
| ACC_ABSTRACT | 0x0400 | 不能被实例化 |
| ACC_SYNTHETIC | 0x1000 | 非 Java 源码生成的代码 |
| ACC_ANNOTATION | 0x2000 | 注解 |
| ACC_ENUM | 0x4000 | 枚举 |  

常量池  
编译器生成的存在于 class 文件中的常量池  
运行时常量池的数据来源  
相同的字面量在常量池里只会存储一份  

常量池项表达范围
- 字面量
    - 文本字符串
    - final 常量值
    - double float long
    - 其他
- 符号引用
    - 类和结构的完全限定名
    - 字段的名称和描述符
    - 方法的名称和描述符  

常量池项的结构  
- tag 表示数据类型  
- info[] 若干个字节构成数组  

| tag | 字面量 | |
| :- | :- | :- |
| 1 | 字符串常量 | CONSTANT_Utf8_info | 
| 3 | 4字节int | CONSTANT_Integer_info |
| 4 | 4字节float | CONSTANT_Float_info |
| 5 | 8字节long | CONSTANT_Long_info |
| 6 | 8字节double | CONSTANT_Double_info |
| 7 | 类或接口的完全限定名 | CONSTANT_Class_info |
| 8 | String 类型 | CONSTANT_String_info |
| 9 | 类中的字段 | CONSTANT_Fieldref_info |
| 10 | 类中的方法 | CONSTANT_Methodref_info |
| 11 | 类所实现的接口的方法 | CONSTANT_InterfaceMethodref_info |
| 12 | 字段或方法的名称和类型 | CONSTANT_NameAndType_info |
| 15 | 方法句柄 | CONSTANT_MethodHandle_info |
| 16 | 方法类型 | CONSTANT_MethodType_info |
| 18 | 用于表示 invokedynamic 指令所使用到的引导方法、引导方法使用到动态调用名称、参数和请求返回类型、以及可选性的附加被称为静态参数的常量序列 | CONSTANT_InvokeDynamic_info |

```
说明 u1 表示一个无符号字节，u2表示两个无符号字节
CONSTANT_Integer_info{
    u1 tag=3;
    u4 bytes;
}
| 3 |   |   |   |   |
|tag|<----bytes---->|

CONSTANT_Float_info{
    u1 tag=4;
    u4 bytes;
}
| 4 |   |   |   |   |
|tag|<----bytes---->|

CONSTANT_Long_info{
    u1 tag=5;
    u4 high_bytes;
    u4 low_bytes;
}
| 5 |   |   |   |   |   |   |   |   |
|tag|<--high_bytes->|<--low_bytes-->|

CONSTANT_Double_info{
    u1 tag=6;
    u4 high_bytes;
    u4 low_bytes;
}
| 6 |   |   |   |   |   |   |   |   |
|tag|<--high_bytes->|<--low_bytes-->|

CONSTANT_String_info{
    u1 tag=8;
    u2 string_index;
}
|      |      |       |
| tag  |<string_index>|
string_index 指向 CONSTANT_Utf8_info 结构体  
```

### 类加载过程  
加载流程：非数组类由类加载器加载 
通过类的全限定名获取类的二进制流  
转为运行时数据结构，放到方法区  
方法区创建 Class 对象作为方法去该类的各种访问入口  

加载数组：由Java虚拟机直接创建，类型通过类加载器加载  

验证流程  
验证重要但不必要（对运行期没有影响）可以通过 `-Xverify:none` 关闭  
保证二进制字节流中的信息符合虚拟机规范  
步骤  
格式检查：基于二进制流进行**魔数验证** **版本检查** **长度检查**  
语义检查：如是否继承final 是否有父类，是否有抽象方法  
字节码指令验证：跳转指令是否指向正确的位置，主要对于方法；操作数类型是否合理  
符号引用验证：符号引用的直接引用是否存在，不存在需要触发其他类的加载  

准备流程  
静态成员变量**分配内存**和设置**初始零值**  

解析流程  
虚拟机将符号引用替换为直接引用  
类或接口、字段、类方法、接口方法  

初始化流程  
对类变量进行手动赋值  
调用静态代码块  
类的初始化过程，就是调用`<clinit>`的过程。`<clinit>` 类初始化方法是编译器自动收集类中所有类变量的赋值动作，和静态代码块中的语句合并产生的  
没有静态代码块也没有类变量的类不会产生`<clinit>`方法  
多线程环境会保证`<clinit>`方法加锁，只有一个线程执行该类的`<clinit>`方法。静态内部类实现的单例模式就是利用了这个机制  
注意定义在静态代码块之后的类变量，静态代码块中可以赋值但是不能访问  
注意区别于`<init>`类构造方法  

类加载的时机  
类加载实际没有强制性约束，但类初始化时机是有规范的  
- new getstatic putstatic invokestatic 时没有初始化的类触发初始化  
- java.lang.reflect 反射调用时  
- 子类发现父类没有初始化，先初始化父类  
- 虚拟机开始启动时初始化 main 方法类  

类加载器  
- 启动类加载器  属于 native，负责加载 JAVA_HOME\lib 目录
- 扩展类加载器  负责加载 JAVA_HOME\lib\ext  
- 应用程序类加载器  负责加载用户路径下的类  
- 自定义加载器  

加载过程，按加载器自底往下检查是否已加载；而加载的顺序是自顶向下  
不同的类加载器加载的同一个类，会形成不同的类对象  

自定义加载器步骤  
- 继承 ClassLoader  
- 重写 findClass() 方法  
- 调用 defineClass() 方法  

双亲委派模型  
- 自底层类加载器向上检查类是否已经加载  
- 检查到 Bootstrap ClassLoader ，如果还是没有加载过这个类，则逐层检查这个类是否属于当前加载器的加载范围，如果不属于则让下一层加载器加载这个类  
- 保证了类不会重复加载  

破坏双亲委派模型  
- 双亲委派模型中，越基础的类越是由上层加载器去加载，遇到基础类要调用用户的代码时，又需要委托底层去加载  

运行时数据区  
除了虚拟机外部的元空间以外，包含了五个部分  
- 方法区 类信息，运行时常量池  
- 堆 对象，数组  
- 虚拟机栈 Java方法执行需要的数据  
- 本地方法栈 native方法执行需要的数据，类似虚拟机栈  
- 程序计数器 存储当前执行代码的行号，不会出现内存溢出  

方法区和堆式线程公有的，需要进行垃圾回收  
线程私有的不需要垃圾回收  

程序计数器  
又叫PC寄存器，可以看作当前线程代码指令的行号指示器  
单核CPU采用时间分片的方式区执行多线程代码  
分支、循环、跳转、异常处理等都需要依赖程序计数器  
如果正在执行Java方法，保存的是这行虚拟机字节码的指针；如果是native方法，保存的是空  

Java 虚拟机栈  
每个Java方法在执行时都会创建一个栈帧用于支持方法调用和方法执行，并在结束时出栈销毁    
最顶端的栈帧称为当前栈帧  
栈帧包含以下部分  
- 局部变量表
- 操作栈  
- 动态连接 指向方法 
- 返回地址  

局部变量表  
存储方法内定义的局部变量，和方法参数  
以变量槽为最小单位，可以存放一个32位以内的数据。如果是long或double则需要两个  
可以保存基本类型、引用类型和returnAddress类型  
一个方法的局部变量表的大小是在编译后就设定好的(locals)  

操作栈  
最大深度在编译时写入到方法的max_stacks  
一个栈帧可以存一个32位以内的数据  

动态连接  
存储指向运行时常量池中虚拟机栈帧所属方法的直接引用  
静态绑定：在类加载时将符号引用解析成直接引用  
动态绑定：只有在运行时才能知道实际需要指向那个地方（如具体到哪个子类的实现方法）  

方法返回
方法有正常完成和异常完成两种退出方式  
返回地址包含了调用这个方法的上一个方法地址  

虚拟机栈异常  
OutOfMemoryError 栈无法申请到更多内存  
StackOverFlowError 栈无法创建更多栈帧，超过最大深度  

本地方法栈  
类似虚拟机栈，是给本地方法用的  
使用 native 修饰的方法都称为本地方法  
一个线程可以在Java栈和本地方法栈之间跳转  

Java 堆
存储对象实例和数组，垃圾回收的主要区域  
并不是所有实例都存在堆中，栈上分配和标量替换  
为了编译回收，堆区进行了更细的划分  
-1.8  
- 新生代（Eden，From Survivor, To Survivor）  
- 老年代  
- 永久代  
1.8 及以后去掉了永久代，取而代之的是独立JVM之外的内存区域，元空间  

堆大小参数 -Xms 初始容量 -Xmx 最大容量  
新生区和幸存区的比例 -XX:SurviorRatio=8  

堆中对象创建过程  
new 指令  
类加载检查  
为对象分配内存（指针碰撞和空闲列表）  
将内存对象初始化为零值  
处理对象头  

指针碰撞：内存地址连续，有明确的分界指示器  
空闲列表：内存地址不连续，在空闲内存碎片中找到合适大小的进行分配   

内存分配原则  
优先在Eden分配，Eden空间不足时触发MinorGC  
大对象直接进入老年代  
长期存活的对象进入老年代，每个对象都有一个age，阈值默认15  

内存分配安全问题  
CAS 比较和交换，乐观锁，失败重试  
TLAB 本地线程分配缓冲，通过CAS预先给线程分配缓冲内存预留给对象使用  

对象的访问方式  
句柄：本地变量表指向句柄池，一个句柄包括一个指向对象实例数据的指针和一个对象类型数据的指针，对象被移动时只需要修改句柄中的地址  
直接指针：直接访问对象实例，省去一次指针跳转，访问速度快  

数组的内存分析  
一维数组：数组在堆中的空间时连续的，每条数据占用的空间都相同，栈内存中只需要记住数组第一条数据的地址，然后通过下标计算偏移量即可  
二维数组：数组中存子数组的第一条数据的地址  

方法区  
HotSpot 1.7之前称为永久代，1.8之后称为元空间。永久代和堆内存相连；元空间位于jvm内存外  
永久代中包含的内容：运行时常量池，静态变量  
元空间中包含的内存：运行时常量池和静态变量移动到了堆中  
为什么要替换：字符串在永久代中容易出现内存溢出；类方法等信息难以确定大小，因此永久代大小指定比较困难；永久代为GC带来不必要的复杂度，回收效率低  

方法区存储的内容  
- 类型信息  
    - 类和父类的全限定名
    - 接口的全限定名
    - 类型标志（类类型和接口类型）
    - 访问描述符（public、private...）
- 类型的常量池  
    - 直接常量（字符串、整数、浮点数）和对其他类型、字段、方法的符号引用 
- 字段信息
    - 字段修饰符（public ...）
    - 字段类型
    - 字段名称  
- 方法信息
    - 方法修饰符
    - 方法返回类型
    - 方法名  
    - 参数个数、顺序、类型  
    - 方法字节码  
    - 方法在栈和操作数栈需要的大小  
    - 异常表  
- 静态变量
- 指向类加载器的引用  
- 指向Class实例的引用（Class.forName(String className)）  
- 方法表，存储了这个类以及父类等所有方法的数组  
- 运行时常量池  

运行时常量池存储内容  
字面量：双引号字符串值和final常量  
符号引用：类或接口的全限定名、变量或方法的名称，参数，返回值、this  

字符串常量池  
全局唯一。哈希链表的数据结构，用于保存双引号字符串的引用  
具有动态性（String.intern()）  
1.6及以前属于方法区的一部分，之后放在堆中  
1.6时stringTable长度时1009，之后可以通过 `-XX:StringTableSize=#`指定  
执行了ldc指令就会进入字符串常量池。凡是遇到双引号字符串就会用到ldc指令  

[next](2.md)  